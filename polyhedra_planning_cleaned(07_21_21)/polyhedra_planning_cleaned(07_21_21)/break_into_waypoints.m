function [outPathWaypoints] = break_into_waypoints(inOptimalPath, inPathSegments)

% Break optimal A*-generated path into a number of waypoints, and plots.
% Chooses coorindate values for waypoints that are evenly spaced apart.

% inputs: 
% inPathSegments = [integer]. number of segments to break the path into
% inOptimalPath = [double array]. the ? x 2 array of coordinate x,y pairs
% constituting the optimal path, generated by A*

% outputs: 
% outPathWaypoints = [double array]. A ? x 2 array of coordinate x,y pairs
% indicating the path waypoints. 

number_of_splits = floor(length(inOptimalPath(:,1))/inPathSegments);
cnt = 1;
path_waypoints_x = [];
path_waypoints_y = [];
for i = 1:length(inOptimalPath(:,1))
    if i == number_of_splits || i == number_of_splits*cnt
        path_waypoints_x(cnt) = inOptimalPath(i,1);
        path_waypoints_y(cnt) = inOptimalPath(i,2);
        cnt = cnt + 1;
    end
end
% need to reverse vector to get correct path from above assignment
path_waypoints_x = fliplr(path_waypoints_x);
path_waypoints_y = fliplr(path_waypoints_y);
path_waypoints = [path_waypoints_x' path_waypoints_y']; % create into column vectors for format consistency purposes

outPathWaypoints = path_waypoints;

% plot the path waypoints for visualization on the current plot
for i = 1:length(path_waypoints_x)
    plot(path_waypoints_x(i), path_waypoints_y(i), '^b', 'MarkerSize', 15)
end

end
